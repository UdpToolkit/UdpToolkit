namespace UdpToolkit.CodeGenerator
{
    using System.Collections.Generic;
    using System.Linq;
    using System.Text;
    using Microsoft.CodeAnalysis;
    using Microsoft.CodeAnalysis.CSharp;
    using Microsoft.CodeAnalysis.CSharp.Syntax;

    /// <summary>
    /// Shared code generator part between Roslyn and source generator.
    /// </summary>
    public static class SyntaxTreesProcessor
    {
        /// <summary>
        /// Generated file name.
        /// </summary>
        public const string GeneratedFileName = "HostWorkerGenerated.cs";

        /// <summary>
        /// Process.
        /// </summary>
        /// <param name="syntaxTrees">The parsed representations of a source documents.</param>
        /// <param name="filterByAttribute">Flag determines the needs filtering of classes by annotation attribute.</param>
        /// <returns>String representation of generated class.</returns>
        public static string Process(
            IEnumerable<SyntaxTree> syntaxTrees,
            bool filterByAttribute)
        {
            var allClasses = syntaxTrees
                .SelectMany(s => s.GetRoot().DescendantNodes())
                .Where(d => d.IsKind(SyntaxKind.ClassDeclaration))
                .OfType<ClassDeclarationSyntax>()
                .ToList();

            if (filterByAttribute)
            {
                allClasses = allClasses
                    .Select(cds => new
                    {
                        @class = cds,
                        attributes = cds.AttributeLists.SelectMany(al => al.Attributes),
                    })
                    .Where(tuple => tuple.attributes.Any(a => a.Name.ToString() == "UdpEvent"))
                    .Select(x => x.@class)
                    .ToList();
            }

            var sb = new StringBuilder();

            GenerateWarningsAboutAutoGeneratedFile(sb);
            GeneratePragma(sb);
            GenerateNamespaces(sb);
            GenerateUsings(sb);
            GenerateClassHeader(sb);
            GenerateLookup(sb, allClasses);
            GenerateProperties(sb);
            GenerateFields(sb);
            GenerateCtorMethod(sb);
            GenerateFinalizerMethod(sb);
            GeneratePublicDisposeMethod(sb);
            GenerateProcessInPacketMethod(sb, allClasses);
            GenerateProcessOutPacketMethod(sb, allClasses);
            GenerateAddFrameworkHeaderMethod(sb);
            GeneratePrivateDisposeMethod(sb);
            GenerateClosedBraces(sb);

            return sb.ToString();
        }

        private static void GenerateWarningsAboutAutoGeneratedFile(StringBuilder sb)
        {
            sb.AppendLine($"// <auto-generated>");
            sb.AppendLine($"// THIS (.cs) FILE IS GENERATED. DO NOT CHANGE IT.");
            sb.AppendLine($"// <auto-generated>");
            sb.AppendLine(string.Empty);
        }

        private static void GenerateLookup(StringBuilder sb, List<ClassDeclarationSyntax> allClasses)
        {
            sb.Append(@"
        private static readonly IReadOnlyDictionary<Type, byte> Lookup = new Dictionary<Type, byte>
        {");

            for (int i = 0; i < allClasses.Count; i++)
            {
                var @class = allClasses[i];
                var ns = GetNamespace(@class);
                var template = @"
            [typeof(TYPE)] = NUMBER,";
                var body = template
                    .Replace("NUMBER", i.ToString())
                    .Replace("TYPE", $"global::{ns.Name.ToString()}.{@class.Identifier.Text}");

                sb.Append(body);
            }

            sb.Append(@"
        };");
        }

        private static void GeneratePragma(StringBuilder sb)
        {
            sb.AppendLine($"#pragma warning disable");
            sb.AppendLine($"#pragma warning disable CS0105");
            sb.AppendLine($"#pragma warning disable S1128");
            sb.AppendLine($"#pragma warning disable SA1516");
            sb.AppendLine($"#pragma warning disable SA1200");
            sb.AppendLine($"#pragma warning disable SA1028");
            sb.AppendLine(string.Empty);
        }

        private static void GenerateNamespaces(StringBuilder sb)
        {
            sb.Append(@"namespace UdpToolkit.Framework
{");
        }

        private static void GenerateUsings(StringBuilder sb)
        {
            sb.Append(@"
    using System;
    using System.Collections.Generic;
    using UdpToolkit.Framework;
    using UdpToolkit.Framework.Contracts;
    using UdpToolkit.Logging;
    using UdpToolkit.Serialization;
    using UdpToolkit.Network.Contracts.Clients;
");
        }

        private static void GenerateClassHeader(StringBuilder sb)
        {
            sb.Append(@"
    public sealed class HostWorkerGenerated : global::UdpToolkit.Framework.Contracts.IHostWorker
    {
");
        }

        private static void GenerateProperties(StringBuilder sb)
        {
            sb.Append(@"
        public global::UdpToolkit.Logging.ILogger Logger { get; set; }
        public global::UdpToolkit.Serialization.ISerializer Serializer { get; set; }
");
        }

        private static void GenerateFields(StringBuilder sb)
        {
            sb.Append(@"
        private bool _disposed = false;
");
        }

        private static void GenerateCtorMethod(StringBuilder sb)
        {
            sb.Append(@"
        public HostWorkerGenerated()
        {
        }
        ");
        }

        private static void GenerateFinalizerMethod(StringBuilder sb)
        {
            sb.Append(@"
        ~HostWorkerGenerated()
        {
            Dispose(false);
        }
        ");
        }

        private static void GeneratePublicDisposeMethod(StringBuilder sb)
        {
            sb.Append(@"
        public void Dispose()
        {
            Dispose(true);
            GC.SuppressFinalize(this);
        }");
        }

        private static void GenerateClosedBraces(StringBuilder sb)
        {
            var end = @"
    }
}";
            sb.Append(end);
        }

        private static void GenerateAddFrameworkHeaderMethod(StringBuilder sb)
        {
            sb.Append(@"
        private byte[] AddFrameworkHeader(byte[] bytes, byte frameworkHeader)
        {
            var buffer = new byte[bytes.Length + 1];
            Buffer.BlockCopy(bytes, 0, buffer, 1, bytes.Length);
            buffer[0] = frameworkHeader;
            return buffer;
        }");
        }

        private static void GeneratePrivateDisposeMethod(StringBuilder sb)
        {
            sb.Append(@"
        private void Dispose(bool disposing)
        {
            if (_disposed)
            {
                return;
            }

            if (disposing)
            {
                // TODO
            }

            _disposed = true;
        }");
        }

        private static void GenerateProcessInPacketMethod(StringBuilder sb, List<ClassDeclarationSyntax> allClasses)
        {
            sb.Append(@"
        public void Process(
            global::UdpToolkit.Framework.Contracts.InPacket inPacket)
        {
            var frameworkHeader = inPacket.Payload[0];
            switch (frameworkHeader)
            {");

            for (int i = 0; i < allClasses.Count; i++)
            {
                var @class = allClasses[i];
                var caseTemplate = @"
                case VALUE:
                    var SUBSCRIPTION = SubscriptionStorage<TYPE>.GetSubscription();
                    var EVENT = Serializer.Deserialize<TYPE>(new ArraySegment<byte>(inPacket.Payload, 1, inPacket.Payload.Length - 1));

                    if (inPacket.Expired)
                    {
                        SUBSCRIPTION?.OnTimeout?.Invoke(
                            inPacket.ConnectionId);
                    }
                    else
                    {
                        SUBSCRIPTION?.OnEvent?.Invoke(
                            inPacket.ConnectionId,
                            inPacket.IpV4Address,
                            EVENT);
                    }

                    break;
             ";

                var ns = GetNamespace(@class);
                var body = caseTemplate
                    .Replace("VALUE", i.ToString())
                    .Replace("EVENT", $"@event{i.ToString()}")
                    .Replace("ROOMID", $"roomId{i.ToString()}")
                    .Replace("SUBSCRIPTION", $"subscription{i.ToString()}")
                    .Replace("TYPE", $"global::{ns.Name.ToString()}.{@class.Identifier.Text}");

                sb.Append(body);
            }

            sb.Append(@"                 
                default:
                    Logger.Error($""[UdpToolkit.Framework] Unsupported frameworkHeader(IN): {frameworkHeader}"");
                    break;
            }
        }");
        }

        private static void GenerateProcessOutPacketMethod(StringBuilder sb, List<ClassDeclarationSyntax> allClasses)
        {
            sb.Append(@"
        public byte[] Process(
            global::UdpToolkit.Framework.Contracts.OutPacket outPacket)
        {
            var frameworkHeader = Lookup[outPacket.Event.GetType()];

            switch (frameworkHeader)
            {");

            for (int i = 0; i < allClasses.Count; i++)
            {
                var @class = allClasses[i];
                var caseTemplate = @"
                case VALUE:
                    var eventBytesVALUE = Serializer.Serialize<TYPE>((TYPE)outPacket.Event);
                    return AddFrameworkHeader(bytes: eventBytesVALUE, frameworkHeader: VALUE);
                 ";

                var ns = GetNamespace(@class);
                var body = caseTemplate
                    .Replace("VALUE", i.ToString())
                    .Replace("TYPE", $"global::{ns.Name.ToString()}.{@class.Identifier.Text}");

                sb.Append(body);
            }

            sb.Append(@"                 
                default:
                    Logger.Error($""[UdpToolkit.Framework] Unsupported frameworkHeader(OUT): {frameworkHeader}"");
                    break;
            }

            return Array.Empty<byte>();
        }");
        }

        private static NamespaceDeclarationSyntax GetNamespace(SyntaxNode syntaxNode)
        {
            if (syntaxNode == null)
            {
                return null;
            }

            try
            {
                syntaxNode = syntaxNode.Parent;

                if (syntaxNode == null)
                {
                    return null;
                }

                if (syntaxNode is NamespaceDeclarationSyntax)
                {
                    return syntaxNode as NamespaceDeclarationSyntax;
                }

                return GetNamespace(syntaxNode);
            }
            catch
            {
                return null;
            }
        }
    }
}